"""Utility methods for accessing local network information."""

import netifaces
from mlab.disco import arp
from mlab.disco import route


class Error(Exception):
    """Base error class for network module."""
    pass


class TooManyInterfaces(Error):
    """Too many physical interfaces were found."""
    pass


class TooFewInterfaces(Error):
    """Too few physical interfaces were found."""
    pass


class NoDefaultGateway(Error):
    """Failed to find a default gateway in the routing table."""
    pass

# Default name for the loopback interface.
_LOOPBACK = 'lo'


def get_local_mac():
    """Discovers the local network interface MAC address.

    Returns:
      str, local MAC address in six-byte hex form: 00:00:00:00:00:00.

    Raises:
      TooManyInterfaces: more than one MAC address is discovered.
      TooFewInterfaces: no MAC addresses are discovered.
    """
    macs = set()

    # Filtering on ^eth? to allow either eth0 (typical) or eth1 (future).
    for iface in filter(lambda x: x.startswith('eth'), netifaces.interfaces()):
        if iface == _LOOPBACK:
            continue
        addrs = netifaces.ifaddresses(iface)
        # AF_LINK is a link layer interface, i.e. the physical interface.
        # AF_INET is an IPv4 address. Allows either eth0 or eth1 to be selected.
        if netifaces.AF_LINK in addrs and netifaces.AF_INET in addrs:
            macs.add(addrs[netifaces.AF_LINK][0]['addr'])

    if not macs:
        raise TooFewInterfaces('Could not find any physical interfaces.')

    if len(macs) > 1:
        raise TooManyInterfaces(
            'Multiple physical interfaces are not supported, found: %s' % macs)

    return macs.pop()


def get_uplink_mac(arp_cache=None):
    """Discovers a MAC address associated with the switch uplink port.

    Multiple MACs may be associated with the switch uplink port. We look
    specifically for the MAC associated with the IPv4 address of the default
    gateway which should always be present.

    Args:
      arp_cache: None or arp.ArpCache, an ARP cache object. If None, use the
          system ARP cache.

    Returns:
      str, a MAC address in six-byte hex form: 00:00:00:00:00:00

    Raises:
      IOError: the routing table or ARP cache files cannot be opened.
      NoDefaultGateway: no default route found in routing table.
      arp.MACNotFound: a MAC address is not found in the ARP cache.
    """
    if not arp_cache:
        arp_cache = arp.ArpCache()

    # TODO(soltesz): replace route.gateways with netifaces.gateways when
    # netifaces-0.10 is available in a system package.
    gateways = route.gateways()
    if 'default' not in gateways or route.AF_INET not in gateways['default']:
        raise NoDefaultGateway('No default route found!')
    return arp_cache.ip_to_mac(gateways['default'][route.AF_INET][0])
