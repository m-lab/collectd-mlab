"""Methods to auto-discover switch information via SNMP."""

import logging

# Third-party modules.
from mlab.disco import network
from mlab.disco import simple_session

# The netsnmp module is a very simple wrapper around the net-snmp library.
# And, unfortunatly, it does not recognize all symbolic OIDs. So, provide a
# direct mapping locally.
_OIDS = {
    'Q-BRIDGE-MIB::dot1qTpFdbPort': '.1.3.6.1.2.1.17.7.1.2.2.1.2',
    'BRIDGE-MIB::dot1dBasePortIfIndex': '.1.3.6.1.2.1.17.1.4.1.2',
    'BRIDGE-MIB::dot1dTpFdbPort': '.1.3.6.1.2.1.17.4.3.1.2',
    'CISCO-VTP-MIB::vtpVlanIfIndex': '.1.3.6.1.4.1.9.9.46.1.3.1.1.18',
}


class Error(Exception):
    """Base error class for discovery module."""
    pass


class PortLookupFailed(Error):
    """Failed to retrieve a port number."""
    pass


class DiscoverySession(object):
    """A session for discovering properties of a switch.

    A DiscoverySession uses a simple session to communicate with a switch via
    SNMP and static switch configurations to probe for live configuration
    information about a switch.

    Example:
        session = simple_session.SimpleSession(netsnmp.Session(
            DestHost=switch_ip, Version=2, Community=switch_community))
        config = models.load_switch_config(switch_config_fd)
        discovery = DiscoverySession(session, config)

        found_ports = discovery.auto_discover_ifindex()
    """

    def __init__(self, session, switch_config):
        """Initializes a DiscoverySession object.

        Args:
            session: simple_session.SimpleSession, an SNMP session object.
            switch_config: models.Config, a switch configuration object.
        """
        self._session = session
        self._switch_config = switch_config
        self._model = None

    def get_model(self):
        """Queries the switch to identify the canonical switch model.

        Returns:
            models.Model, the configuration object for the canonical switch
                model.

        Raises:
            models.MultipleMatches: more than one switch model matched the
                system description returned by the switch.
            models.UnsupportedSwitchModel: the model cannot be identified from
                the system description.
            simple_session.SNMPError: failure to communitate with the switch.
        """
        if not self._model:
            sys_descr = self._session.get('sysDescr.0')
            # For a single session, the switch model will not change.
            self._model = self._switch_config.get_model(sys_descr[0].value)
        return self._model

    def auto_discover_ifindex(self):
        """Auto-discovers the ifIndex for local and uplink switch ports.

        SNMP statistics about switch port traffic are stored in MIBs addressed
        using per-port interface indexes, or simply "ifIndex." The ifIndex is
        used to address specific counters for specific ports. For example,
        IF-MIB::ifHCInOctets.{ifIndex} reports received bytes on the given
        ifIndex.

        Returns:
            list of (str, str) tuples, corresponding to the port name and
                ifIndex number, e.g. [('uplink', '24'), ('local', '9')]

        Raises:
            arp.MACNotFound: a MAC address is not found in the ARP cache.
            models.MultipleMatches: more than one switch model matched the
                system description.
            models.UnsupportedSwitchModel: the model cannot be identified from
                the system description.
            network.NoDefaultGateway: no default route found in routing table.
            network.TooManyInterfaces: more than one MAC address is discovered.
            network.TooFewInterfaces: no MAC addresses are discovered.
            PortLookupFailed: failure identifying ifIndex using
                BRIDGE-MIB::dot1dBasePortIfIndex.
            simple_session.SNMPError: failure to communitate with the switch.
        """
        model = self.get_model()

        macs = {}
        macs['local'] = _mac_to_oid(network.get_local_mac())
        macs['uplink'] = _mac_to_oid(network.get_uplink_mac())

        return self._lookup_ifindex(macs, qbridge=model.qbridge)

    def auto_discover_vlan(self):
        """Auto-discovers switch VLANs.

        Returns:
            list of str, each element is a possible VLAN id. An empty list means
                there are no VLANs configured.

        Raises:
            models.MultipleMatches: more than one switch model matched the
                system description.
            models.UnsupportedSwitchModel: the model cannot be identified from
                the system description.
            simple_session.SNMPError: failure to communicate with switch.
        """
        vlans = []
        model = self.get_model()
        if not model.vlan:
            return vlans

        for item in self._session.walk(_OIDS['CISCO-VTP-MIB::vtpVlanIfIndex']):
            if item.value not in ['0']:
                vlans.append(item.value)

        return vlans

    def _lookup_ifindex(self, macs, qbridge=False):
        """Performs discovery of ifIndex for switch ports.

        Args:
            macs: dict, mapping of port names to MAC addreses in OID form.
            qbridge: bool, whether to use Q-BRIDGE MIB for port lookup.

        Returns:
            list of (str, str) tuples, corresponding to the port name and
                ifIndex number, e.g. [('uplink', '24'), ('local', '9')]

        Raises:
            PortLookupFailed: failure identifying ifIndex using
                BRIDGE-MIB::dot1dBasePortIfIndex.
            simple_session.SNMPError: switch query failed for another reason.
        """
        found_ports = []

        # See https://tools.ietf.org/html/rfc1496 for BRIDGE-MIB definitions.
        # See https://tools.ietf.org/html/rfc2674 for Q-BRIDGE-MIB definitions.
        if qbridge:
            bridge_oid = _OIDS['Q-BRIDGE-MIB::dot1qTpFdbPort']
        else:
            bridge_oid = _OIDS['BRIDGE-MIB::dot1dTpFdbPort']

        bridge_ports = self._session.walk(bridge_oid)
        for port_name, mac_oid in macs.iteritems():
            for bridge_port in bridge_ports:
                logging.debug('Looking for %s in %s', mac_oid, bridge_port.oid)
                if mac_oid not in bridge_port.oid:
                    continue

                baseport_oid = _OIDS['BRIDGE-MIB::dot1dBasePortIfIndex']
                try:
                    ifindex = self._session.get(baseport_oid + '.' +
                                                bridge_port.value)
                except simple_session.SNMPError:
                    raise PortLookupFailed(
                        'Found MAC OID (%s), but failed to retrieve port' %
                        mac_oid)
                ifindex_num = ifindex[0].value

                logging.debug('Found: ifIndex for %s is %s', mac_oid,
                              ifindex_num)
                found_ports.append((port_name, ifindex_num))
                # We found a matching OID, so continue to next port name.
                break

        return found_ports


def _mac_to_oid(mac):
    """Converts a six-byte hex form MAC address to six-byte decimal form.

    For example:
        00:1A:2B:3C:4D:5E converts to 0.26.43.60.77.94

    Returns:
        str, six-byte decimal form used in SNMP OIDs.
    """
    fields = mac.split(':')
    oid_fields = [str(int(v, 16)) for v in fields]
    oid = '.'.join(oid_fields)
    return oid
