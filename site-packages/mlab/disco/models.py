"""Functions to identify switch models and their unique OIDs."""

import copy
import yaml


class Error(Exception):
    """Base error class for models."""
    pass


class UnknownSwitchModel(Error):
    """The switch model is not known."""
    pass


class UnknownOIDName(Error):
    """OID name is not supported."""
    pass


class MultipleMatches(Error):
    """More than one matched occurred when one was expected."""
    pass


class BadConfiguration(Error):
    """An error occurred while reading configuration."""
    pass


def load_switch_config(config_fd):
    """Loads the switch configuration from config_fd.

    Args:
        config_fd: readable file-like object, contains the switch configuration.

    Returns:
        Config, the complete model and OID switch configuraion.

    Raises:
        BadConfiguration: the yaml configuration contained an error.
    """
    try:
        return yaml.safe_load(config_fd)
    except (AttributeError, yaml.MarkedYAMLError, TypeError) as err:
        raise BadConfiguration('Failed to parse config: %s' % err)


class BaseYAMLObject(yaml.YAMLObject):

    # Note: we override the default from_yaml classmethod so that  __init__ is
    # called during object creation. Surprisingly, this is not the default,
    # which delays setting default attribute values or enforcing constraints on
    # attributes until after parsing. Unfortunately, error messages from
    # incomplete objects are unhelpful. So, we adopt a convention of setting
    # default values for all __init__ parameters and enforcing them at init
    # time, so that clear error messages can be delivered to callers.

    @classmethod
    def from_yaml(cls, loader, node):
        fields = loader.construct_mapping(node, deep=True)
        # start_mark helps indicate where in the yaml config an error occurred.
        fields['line'] = node.start_mark
        return cls(**fields)


class Config(BaseYAMLObject):
    """Configuration interface for switch models.

    Switch configuration files must contain two top level attributes for
    'models' and 'default_oids'.

    Example:
        !config
        models:
            ...

        default_oids:
            ...
    """

    yaml_tag = u'!config'
    yaml_loader = yaml.SafeLoader

    def __init__(self, models=None, default_oids=None, **kwargs):
        """Initializes the object.

        Args:
          models: list of Model, the models for this config.
          default_oids: dict of OID, a mapping from OID names to OID objects.
          **kwargs: dict, remaining key word arguments. kwargs['line'] is used
              to report errors.
        """
        if not models or default_oids is None:
            raise BadConfiguration(
                '%s: Config must contain nodes for "models" and "default_oids".'
                % kwargs.get('line', 'unknown'))

        self.models = models
        self.default_oids = default_oids
        self._populate_model_oids()

    def _populate_model_oids(self):
        """Populates the model OIDs based on the configuration default_oids."""
        for model in self.models:
            total_oids = copy.deepcopy(self.default_oids)
            if model.oids:
                # Override the default oids with model-specific configuration.
                for name, oid in model.oids.iteritems():
                    total_oids[name] = oid
            # Save the full model-specific configuration.
            model.oids = total_oids

    def __repr__(self):  # pragma: no cover
        return 'Config(models="%s", oids="%s")' % (self.models,
                                                   self.default_oids)

    def get_model(self, sysdescr):
        """Returns a model configuration based on the switch model.

        Args:
            sysdescr: str, the value returned for the sysDescr.0 OID.

        Returns:
            Model, a switch configuration based on the switch model.

        Raises:
            UnknownSwitchModel: could not identify the model corresponding to
                sysdescr.
            MultipleMatches: more than one switch model matched the sysdescr.
        """
        matches = []
        patterns = []
        for model in self.models:
            if model.pattern in sysdescr:
                patterns.append(model.pattern)
                matches.append(model)
        if not matches:
            raise UnknownSwitchModel('Unknown switch model: %s' % sysdescr)
        if len(matches) > 1:
            raise MultipleMatches(
                ('Multiple switch models matched: %s. Update the model '
                 'configurations to use more precise patterns for: %s') %
                (patterns, sysdescr))
        return matches[0]


class Model(BaseYAMLObject):
    """Accesses configuration information for a specific switch model.

    Model configuration nodes must contain a "name" and "pattern" value. Other
    values are optional and default False or empty.

    If "oids" is specified, then these values will override the corresponding
    OID name from "default_oids".

    Example:
        models:
            - !model
              name: qfx
              pattern: qfx
              oids:
                  discards:
                      !oid
                      rx: RFC1213-MIB::ifInDiscards.{ifIndex}
                      tx: SPECIAL-MIB::ifFancyOutDiscards.{ifIndex}
    """

    yaml_loader = yaml.SafeLoader
    yaml_tag = u'!model'

    def __init__(self,
                 name=None,
                 pattern=None,
                 qbridge=False,
                 vlan=False,
                 oids=None,
                 **kwargs):
        if not name or not pattern:
            raise BadConfiguration(
                '%s: Model "name" and "pattern" must be specified.' %
                kwargs.get('line', 'unknown'))
        self.name = name
        self.pattern = pattern
        self.qbridge = qbridge
        self.vlan = vlan
        self.oids = {} if oids is None else oids

    def __repr__(self):  # pragma: no cover
        return 'Model(name="%s", pattern="%s", qbridge=%s, oids=%s)' % (
            self.name, self.pattern, self.qbridge, self.oids)

    def oid_names(self):
        """Returns list of OID names in the model OID configuration."""
        return self.oids.keys()

    def lookup_oids(self, oid_name, ifindex):
        """Returns the input and output OIDs for oid_name on ifindex.

        Args:
          oid_name: str, a supported oid_name; one returned by
              SwitchConfig.oid_names.
          ifindex: str, the interface index number as returned by
              DiscoverySession.auto_discover_ports.

        Returns:
          tuple of (str, str), containing the input and output OID for oid_name.

        Raises:
          UnknownOIDName: the oid_name is not supported.
        """
        try:
            oid = self.oids[oid_name]
        except KeyError as err:
            raise UnknownOIDName('Unknown OID name: %s' % err)

        return (oid.rx.format(ifIndex=ifindex), oid.tx.format(ifIndex=ifindex))


class OID(BaseYAMLObject):
    """Configuration information for an OID pair.

    Both the "rx" and "tx" values must be specified.

    Example:
        !oid
        rx: RFC1213-MIB::ifInDiscards.{ifIndex}
        tx: RFC1213-MIB::ifOutDiscards.{ifIndex}
    """

    yaml_loader = yaml.SafeLoader
    yaml_tag = u'!oid'

    def __init__(self, rx=None, tx=None, **kwargs):
        if not rx or not tx:
            raise BadConfiguration('%s: OID "rx" and "tx" must be specified.' %
                                   kwargs.get('line', 'unknown'))
        self.rx = rx
        self.tx = tx

    def __repr__(self):  # pragma: no cover
        return 'OID(rx="%s", tx="%s")' % (self.rx, self.tx)
