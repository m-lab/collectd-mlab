#!/usr/bin/python
# Copyright 2014 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Summary:
  mlab-view provides a limited web server to view the collectd-web CGI scripts.

  While mlab-view is running, an operator can only access the CGI scripts using
  an SSH tunnel. Direct web connections are refused with "403 Forbidden."

  mlab-view should only be used for debugging and node triage. When a node is
  in normal operation, mlab-view should not be running. mlab-view guarantees
  that the web server is shutdown when the operator's ssh connection has
  disconnected.

Example usage (from operator's workstation):

  $ ssh -L 8088:utility.mlab.<hostname>:8088 \\
      -p806 mlab_utility@<hostname> sudo mlab-view

  Operator directs their browser to:

      http://localhost:8088/

What's happening?

 * SSH binds to port 8088 on localhost.
 * SSH login to <hostname> as the mlab_utility user and runs the command:

     "sudo mlab-view".

 * mlab-view starts a web server that listens on port 8088.
 * The web server is configured to reject connections from any address other
   than the slice IP.
 * When ssh detects a connection to localhost:8088, the remote end attempts a
   connection to:

      "utility.mlab.<hostname>:8088"

   To the server, this connection appears to come from the slice IP.
 * SSH continues to forward all traffic back and forth from localhost:8088
   through the ssh connection to the remote web server.
"""

import os
import signal
import subprocess
import sys
import syslog
import time

# Third-party modules.
import netifaces


ACCESS_CONF = '/usr/share/collectd-mlab/access.conf'
HTTPD_BIN = '/usr/sbin/httpd'
HTTPD_CONFIG = '/usr/share/collectd-mlab/httpd.conf'
HTTPD_PID = '/etc/httpd/run/httpd.pid'


def log(msg):
  """Sends log message to syslog."""
  print msg
  syslog.syslog(syslog.LOG_ERR, 'mlab-view: %s' % msg)


def ignore_signal_handler(signal, _):
  """Handler to ignore any signal."""
  log('Ignoring signal: %s' % signal)


def get_address():
  """Returns local IPv4 & IPv6 addresses as a string separated by spaces."""
  addrs = []
  for iface in netifaces.interfaces():
    if iface == 'lo':
      continue
    addresses = netifaces.ifaddresses(iface)
    for addr_type in (netifaces.AF_INET, netifaces.AF_INET6):
      if addr_type in addresses:
        addrs.extend([addr['addr'] for addr in addresses[addr_type]])
  if not addrs:
    return '127.0.0.1'
  return ' '.join(addrs)


def get_access_config():
  return """
<Directory /usr/share/collectd/>
    AddHandler cgi-script .cgi
    DirectoryIndex bin/index.cgi
    Order Deny,Allow
    Deny from all
    Allow from {ips}
</Directory>
""".format(ips=get_address())


def find_last_parent(pid):
  """Walks up process tree starting at pid, stopping at sshd or ppid == 1."""
  try:
    status_lines = open('/proc/%s/status' % pid, 'r').readlines()
  except IOError:
    return -1

  name_lines = filter(lambda x: x.startswith('Name:'), status_lines)
  if not name_lines:
    return -1

  ppid_lines = filter(lambda x: x.startswith('PPid:'), status_lines)
  if not ppid_lines:
    return -1

  # If the process name contains 'sshd', we'll stop there.
  ppid = int(ppid_lines[0].split()[1])
  if 'sshd' in name_lines[0] or ppid == 1:
    return ppid

  # Continue up the tree.
  return find_last_parent(ppid)


def main():
  signal.signal(signal.SIGINT, ignore_signal_handler)
  signal.signal(signal.SIGTERM, ignore_signal_handler)

  try:
    # Unconditionally write httpd access rule with local IP address.
    open(ACCESS_CONF, 'w').write(get_access_config())
  except IOError as err:
    log(err)
    sys.exit(1)

  if os.path.exists(HTTPD_PID):
    log('httpd pid file present. Is httpd already running?')
    sys.exit(1)

  # TODO: what other options are available for serving the cgi files?
  args = [HTTPD_BIN, '-X', '-f', HTTPD_CONFIG]
  try:
    child = subprocess.Popen(args)
  except OSError as err:
    log(err)
    sys.exit(1)

  log('Started web server pid:%s' % child.pid)
  pid = os.getpid()
  while True:
    ppid = find_last_parent(pid)
    if ppid == 1:
      # When started via ssh, there is a chain of processes from sshd to the
      # web server. When the ssh session ends, the first child's parent is set
      # to pid 1. Once this occurs, no one is interacting with server.  So,
      # kill the server.
      break
    time.sleep(1)

  log('Killing web server pid:%s' % child.pid)
  child.kill()
  try:
    os.remove(HTTPD_PID)
  except OSError:
    pass


if __name__ == '__main__':
  main()
